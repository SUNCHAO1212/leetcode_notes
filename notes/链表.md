# 链表

## 1.找出两个链表的交点

160. 相交链表
https://leetcode.cn/problems/intersection-of-two-linked-lists/submissions/


### 思路1
遍历获得长度，长链表指针向后移动差值个节点，逐个判断是否相同至结束


``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:

        if not headA or not headB:
            return None 
        len1 = 0
        len2 = 0
        tmp_node_1 = headA
        tmp_node_2 = headB
        while tmp_node_1.next is not None:
            tmp_node_1 = tmp_node_1.next
            len1 += 1
        while tmp_node_2.next is not None:
            tmp_node_2 = tmp_node_2.next
            len2 += 1
        
        tmp_node_1 = headA
        tmp_node_2 = headB
        if len1 > len2:
            for i in range(len1-len2):
                tmp_node_1 = tmp_node_1.next
        elif len2 > len1:
            for i in range(len2-len1):
                tmp_node_2 = tmp_node_2.next
        
        while tmp_node_1 and tmp_node_2:
            if tmp_node_1 == tmp_node_2:
                return tmp_node_1
            else:
                tmp_node_1 = tmp_node_1.next
                tmp_node_2 = tmp_node_2.next
        return None
``` 
### 思路2

大佬思路：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md

### 思路3
空间复杂度O（n），不满足题目要求，但是快啊

``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        
        # 空间复杂度O(n)
        union = set()
        l1 = headA
        while l1:
            union.add(l1)
            l1 = l1.next
        l2 = headB
        while l2:
            if l2 in union:
                return l2
            l2 = l2.next 
        return None 

```
## 2.反转链表
206. 反转链表
https://leetcode.cn/problems/reverse-linked-list/

迭代法
``` python 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 迭代
        new_head = None 
        while head:
            cur = ListNode(head.val)
            cur.next = new_head
            new_head = cur  
            head = head.next 
        return new_head
```

递归法
+ 第零轮：1->2->3->4->5
+ 第一轮：1->2->3->4<-5
+ 第二轮：1->2->3<-4<-5
``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 递归

        # 判断边界
        if not head or not head.next:
            return head
        # 递归获得 head.next 的翻转
        last = self.reverseList(head.next)
        # 当前节点翻转
        head.next.next = head 
        head.next = None 

        return last
```

## 3. 归并两个有序链表
21. 合并两个有序链表
https://leetcode.cn/problems/merge-two-sorted-lists/
``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        
        cur = new_head = ListNode(0) 
        while list1 and list2:
            if list1.val <= list2.val:
                cur.next = list1 
                cur = cur.next 
                list1 = list1.next 
            else:
                cur.next = list2
                cur = cur.next 
                list2 = list2.next 
        if list1:
            cur.next = list1
        if list2:
            cur.next = list2

        return new_head.next
```
